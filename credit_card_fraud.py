# -*- coding: utf-8 -*-
"""Credit card fraud.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12fuiu-qNOmfPQ71_iF9qdFwSsBvQezjS
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.impute import SimpleImputer
import pandas as pd
import matplotlib.pyplot as plt
# Load the dataset
file_path = '/content/creditcard.csv'
pd.read_csv(file_path)

df = pd.read_csv(file_path)
rows,coloums=df.shape
print(f"The dataset contains {rows}  rows and {coloums} columns.")
print("Column names:")
for col in df.columns:
    print(col)

class_counts = df['Class'].value_counts()
print(f"\nClass 0: {class_counts[0]} normal transactions")
print(f"Class 1: {class_counts[1]} fraudulent transactions")

# Create pie chart
class_counts = df['Class'].value_counts()
labels = ['Normal', 'Fraudulent']
sizes = [class_counts[0], class_counts[1]]
colors = ['lightblue', 'red']
explode = (0.1, 0)
plt.figure(figsize=(8, 6))
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)
plt.title('Proportion of Normal vs. Fraudulent Transactions')
plt.axis('equal')
plt.legend(labels, loc='center left', bbox_to_anchor=(1, 0.5))
plt.show()

# Train a logistic regression model

missingvalues = SimpleImputer(strategy='mean')
data_imputed = pd.DataFrame(missingvalues.fit_transform(df), columns=df.columns)
data_imputed['Class'] = data_imputed['Class'].astype(int)
X = data_imputed.drop('Class', axis=1)
y = data_imputed['Class']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))
print('Accuracy:', accuracy_score(y_test, y_pred))
#--> CM matrix for Logistic Regression
matrix_lr = confusion_matrix(y_test, y_pred)
cm_lr = pd.DataFrame(matrix_lr, index=['not_fraud', 'fraud'], columns=['not_fraud', 'fraud'])

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
cmap = ListedColormap(['lightcoral', 'lightgreen'])
sns.heatmap(cm_lr, annot=True, cbar=None, cmap=cmap, fmt = 'g')
plt.title("Confusion Matrix Logistic Regression"), plt.tight_layout()
plt.ylabel("True Class"), plt.xlabel("Predicted Class")
plt.show()

# Train an SVM model
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
X = data_imputed.drop('Class', axis=1)
y = data_imputed['Class']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
svm_model = SVC(kernel='linear')
svm_model.fit(X_train, y_train)
y_pred_svm = svm_model.predict(X_test)
# Evaluate the SVM model
print("\nSVM Model Evaluation:")
print(classification_report(y_test, y_pred_svm))
print(confusion_matrix(y_test, y_pred_svm))
print('Accuracy:', accuracy_score(y_test, y_pred_svm))

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
cmap = ListedColormap(['lightcoral', 'lightgreen'])

# create the confusion matrix
cm_svm = confusion_matrix(y_test, y_pred_svm)

# use the confusion matrix cm_svm in the heatmap
sns.heatmap(cm_svm, annot=True, cbar=None, cmap=cmap, fmt = 'g')
plt.title("Confusion Matrix SVM"), plt.tight_layout()
plt.ylabel("True Class"), plt.xlabel("Predicted Class")
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.impute import SimpleImputer
import pandas as pd
import matplotlib.pyplot as plt
# Load the dataset
file_path = '/content/creditcard.csv'
pd.read_csv(file_path)
df = pd.read_csv(file_path)
rows,coloums=df.shape
print(f"The dataset contains {rows}  rows and {coloums} columns.")
print("Column names:")
for col in df.columns:
    print(col)

    # Create pie chart
class_counts = df['Class'].value_counts()
labels = ['Normal', 'Fraudulent']
sizes = [class_counts[0], class_counts[1]]
colors = ['lightblue', 'red']
explode = (0.1, 0)
plt.figure(figsize=(8, 6))
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)
plt.title('Proportion of Normal vs. Fraudulent Transactions')
plt.axis('equal')
plt.legend(labels, loc='center left', bbox_to_anchor=(1, 0.5))
plt.show()
# Train a logistic regression model

missingvalues = SimpleImputer(strategy='mean')
data_imputed = pd.DataFrame(missingvalues.fit_transform(df), columns=df.columns)
data_imputed['Class'] = data_imputed['Class'].astype(int)
X = data_imputed.drop('Class', axis=1)
y = data_imputed['Class']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))
print('Accuracy:', accuracy_score(y_test, y_pred))
#--> CM matrix for Logistic Regression
matrix_lr = confusion_matrix(y_test, y_pred)
cm_lr = pd.DataFrame(matrix_lr, index=['not_fraud', 'fraud'], columns=['not_fraud', 'fraud'])

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
cmap = ListedColormap(['lightcoral', 'lightgreen'])
sns.heatmap(cm_lr, annot=True, cbar=None, cmap=cmap, fmt = 'g')
plt.title("Confusion Matrix Logistic Regression"), plt.tight_layout()
plt.ylabel("True Class"), plt.xlabel("Predicted Class")
plt.show()


# Train an SVM model
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
X = data_imputed.drop('Class', axis=1)
y = data_imputed['Class']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
svm_model = SVC(kernel='linear')
svm_model.fit(X_train, y_train)
y_pred_svm = svm_model.predict(X_test)
# Evaluate the SVM model
print("\nSVM Model Evaluation:")
print(classification_report(y_test, y_pred_svm))
print(confusion_matrix(y_test, y_pred_svm))
print('Accuracy:', accuracy_score(y_test, y_pred_svm))

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
cmap = ListedColormap(['lightcoral', 'lightgreen'])

# create the confusion matrix
cm_svm = confusion_matrix(y_test, y_pred_svm)

# use the confusion matrix cm_svm in the heatmap
sns.heatmap(cm_svm, annot=True, cbar=None, cmap=cmap, fmt = 'g')
plt.title("Confusion Matrix SVM"), plt.tight_layout()
plt.ylabel("True Class"), plt.xlabel("Predicted Class")
plt.show()